/* eslint-disable no-param-reassign */
// @flow
import _cloneDeep from 'lodash/cloneDeep';
import _uniqueId from 'lodash/uniqueId';
import { createSlice } from '@reduxjs/toolkit';
import type { PayloadAction } from '@reduxjs/toolkit';

import { EMPTY_SELECTION } from '@kitman/components/src/Athletes/constants';
import { colors } from '@kitman/common/src/variables';
import { type SquadAthletesSelection } from '@kitman/components/src/Athletes/types';
import {
  type FilterType,
  type FilterValue,
  type ChartElement,
} from '@kitman/modules/src/analysis/shared/types/charts';
import {
  type Grouping,
  type DataSourceFormState,
  type DataSourceInput,
  type RenderOptionType,
  type RenderOptionValue,
  type TimeScopeOption,
} from '@kitman/modules/src/analysis/Dashboard/components/ChartBuilder/types';
import { type TableWidgetDataSource } from '@kitman/modules/src/analysis/Dashboard/components/TableWidget/types';
import { type ChartWidgetData } from '@kitman/modules/src/analysis/Dashboard/components/ChartWidget/types';
import { type ChartConfig } from '@kitman/modules/src/analysis/shared/components/XYChart/types';
import {
  formatChartInputParams,
  getDataTypeSource,
} from '@kitman/modules/src/analysis/Dashboard/utils';

export const REDUCER_KEY = 'chartBuilder';

export type FormMode = 'update' | 'create';

type ChartIDString = string;
type WidgetIDString = string;
type ChartElementIDString = string;

type WidgetMap = {
  [WidgetIDString]: ChartWidgetData,
};

export type ChartBuilderState = {
  newChartModal: {
    isOpen: boolean,
  },
  groupings?: Array<Grouping>,
  // active widgets is map of widgets that have edit mode active
  activeWidgets: WidgetMap,
  dataSourceSidePanel: {
    mode: FormMode,
    isOpen: boolean,
    widgetId?: WidgetIDString,
    chartId?: number,
    previewData?: DataSourceFormState,
    sidePanelSource?: TableWidgetDataSource,
    dataSourceFormState: DataSourceFormState,
  },
  chartFormattingPanel: {
    isOpen: boolean,
    appliedFormat: Array<Object>,
  },
  loaderLevelMap?: {
    [WidgetIDString]: number,
  },
  [ChartIDString]: {
    config: ChartConfig,
  },
  invalidChartElementMap?: {
    [ChartIDString]: {
      [ChartElementIDString]: Array<string>,
    },
  },
  refreshWidgetCacheMap?: {
    [WidgetIDString]: boolean,
  },
  cachedAtMap?: {
    [WidgetIDString]: Array<string>,
  },
};

export const emptyDataSourceFormState = {
  data_source_type: '',
  calculation: '',
  input_params: {},
  overlays: null,
  population: { ...EMPTY_SELECTION },
  time_scope: {
    time_period: null,
    start_time: null,
    end_time: null,
    time_period_length: null,
    time_period_length_offset: null,
  },
  config: null,
};

export const defaultDataSourceSidePanel = {
  isOpen: false,
  mode: 'create',
  dataSourceFormState: { ...emptyDataSourceFormState },
};

export const initialState: ChartBuilderState = {
  newChartModal: {
    isOpen: false,
  },
  activeWidgets: {},
  dataSourceSidePanel: {
    mode: 'create',
    isOpen: false,
    dataSourceFormState: { ...emptyDataSourceFormState },
  },
  chartFormattingPanel: {
    isOpen: false,
    appliedFormat: [],
  },
};

const chartBuilder = createSlice({
  name: REDUCER_KEY,
  initialState,
  reducers: {
    newChart(state: ChartBuilderState) {
      state.newChartModal.isOpen = true;
    },
    closeNewChartModal(state: ChartBuilderState) {
      state.newChartModal.isOpen = false;
      state.dataSourceSidePanel = defaultDataSourceSidePanel;
    },
    closeDataSourcePanel(state: ChartBuilderState) {
      state.dataSourceSidePanel = { ...defaultDataSourceSidePanel };
    },
    beginWidgetEditMode(
      state: ChartBuilderState,
      action: PayloadAction<ChartWidgetData>
    ) {
      const widgetData: ChartWidgetData = action.payload;

      state.activeWidgets[`${widgetData.id}`] = _cloneDeep(widgetData);
    },
    endWidgetEditMode(state: ChartBuilderState, action: PayloadAction<number>) {
      const widgetId = action.payload;

      delete state.activeWidgets[`${widgetId}`];

      return state;
    },
    setAllGroupings(
      state: ChartBuilderState,
      action: PayloadAction<Array<Grouping>>
    ) {
      state.groupings = action.payload;
    },
    addDataType(
      state: ChartBuilderState,
      action: PayloadAction<{
        source: string,
        widgetId: string,
        chartId: number,
      }>
    ) {
      state.dataSourceSidePanel.sidePanelSource = action.payload.source;
      /**
       * Server-side identification of temporary chart element IDs in the /preview payload.
       * A negative ID signifies that it was generated by the front-end for temporary use,
       * preventing conflicts with permanent IDs.
       * Conversation Format example: "1234" -> "-1234"
       */
      state.dataSourceSidePanel.dataSourceFormState.id = `-${_uniqueId()}`;
      state.dataSourceSidePanel.isOpen = true;
      state.dataSourceSidePanel.widgetId = action.payload.widgetId;
      state.dataSourceSidePanel.chartId = action.payload.chartId;

      // add default values for medical source
      if (action.payload.source === 'medical') {
        const formState = state.dataSourceSidePanel.dataSourceFormState;
        formState.type = 'MedicalInjury';
        formState.data_source_type = 'MedicalInjury';
        formState.calculation = 'count_absolute';
      }
    },
    editDataType(
      state: ChartBuilderState,
      action: PayloadAction<{
        widgetId: string,
        chartId: number,
        chart_element: DataSourceFormState,
      }>
    ) {
      state.dataSourceSidePanel.dataSourceFormState = {
        ...action.payload.chart_element,
      };
      state.dataSourceSidePanel.sidePanelSource = getDataTypeSource(
        action.payload.chart_element.data_source_type
      );
      state.dataSourceSidePanel.widgetId = action.payload.widgetId;
      state.dataSourceSidePanel.chartId = action.payload.chartId;
      state.dataSourceSidePanel.mode = 'update';
      state.dataSourceSidePanel.isOpen = true;
    },
    applyChartElement(
      state: ChartBuilderState,
      action: PayloadAction<{ data: DataSourceFormState }>
    ) {
      const widgetId = state.dataSourceSidePanel.widgetId;

      if (widgetId) {
        const widget = state?.activeWidgets[widgetId]?.widget;

        if (widget?.chart_elements) {
          widget.chart_elements.push({
            ...action.payload.data,
          });
        } else {
          widget.chart_elements = [{ ...action.payload.data }];
        }
      }

      state.dataSourceSidePanel = defaultDataSourceSidePanel;
    },
    updateChartElement(
      state: ChartBuilderState,
      action: PayloadAction<{
        widgetId: string,
        formattedState: DataSourceFormState,
      }>
    ) {
      const dataSource =
        action.payload?.formattedState ??
        state.dataSourceSidePanel.dataSourceFormState;

      if (action.payload.widgetId) {
        const widget = state.activeWidgets[action.payload.widgetId].widget;
        const index = widget.chart_elements.findIndex((element) => {
          return element.id === dataSource.id;
        });

        if (index !== -1)
          widget.chart_elements.splice(index, 1, {
            ...dataSource,
          });
      }

      state.dataSourceSidePanel = defaultDataSourceSidePanel;
    },
    deleteChartElement(state: ChartBuilderState) {
      const widgetId = state.dataSourceSidePanel.widgetId;
      const dataSource = state.dataSourceSidePanel.dataSourceFormState;

      if (widgetId) {
        const widget = state.activeWidgets[widgetId].widget;
        const index = widget.chart_elements.findIndex((element) => {
          return element.id === dataSource.id;
        });

        if (index !== -1) {
          widget.chart_elements.splice(index, 1);
        }

        state.dataSourceSidePanel = defaultDataSourceSidePanel;
      }
    },
    updatePreviewChartData(
      state: ChartBuilderState,
      action: PayloadAction<string>
    ) {
      state.dataSourceSidePanel.previewData =
        action.payload?.formattedState ??
        state.dataSourceSidePanel.dataSourceFormState;
    },
    addCalculation(state: ChartBuilderState, action: PayloadAction<string>) {
      state.dataSourceSidePanel.dataSourceFormState.calculation =
        action.payload;

      if (
        state.dataSourceSidePanel.dataSourceFormState.config?.calculation_params
      ) {
        state.dataSourceSidePanel.dataSourceFormState.config.calculation_params =
          {};
      }
    },
    addCalculationParams(state: ChartBuilderState, action) {
      if (!state.dataSourceSidePanel.dataSourceFormState?.config) {
        state.dataSourceSidePanel.dataSourceFormState.config = {};
      }

      if (
        !state.dataSourceSidePanel.dataSourceFormState.config
          ?.calculation_params
      ) {
        state.dataSourceSidePanel.dataSourceFormState.config.calculation_params =
          {};
      }

      state.dataSourceSidePanel.dataSourceFormState.config.calculation_params =
        {
          ...state.dataSourceSidePanel.dataSourceFormState.config
            .calculation_params,
          ...action.payload,
        };
    },
    addInputParams(
      state: ChartBuilderState,
      action: PayloadAction<{ type: string, data: Array<DataSourceInput> }>
    ) {
      state.dataSourceSidePanel.dataSourceFormState.type = action.payload.type;

      const formattedInputParams = formatChartInputParams(
        action.payload.type,
        action.payload.data
      );

      state.dataSourceSidePanel.dataSourceFormState.data_source_type =
        action.payload.type;
      state.dataSourceSidePanel.dataSourceFormState.input_params =
        formattedInputParams;
    },
    addPopulation(
      state: ChartBuilderState,
      action: PayloadAction<SquadAthletesSelection>
    ) {
      state.dataSourceSidePanel.dataSourceFormState.population = action.payload;
    },
    addTimeScope(
      state: ChartBuilderState,
      action: PayloadAction<{ key: TimeScopeOption, value: string | number }>
    ) {
      state.dataSourceSidePanel.dataSourceFormState.time_scope = {
        ...state.dataSourceSidePanel.dataSourceFormState.time_scope,
        [action.payload.key]: action.payload.value,
      };
    },
    addDataSourceGroupingByIndex(
      state: ChartBuilderState,
      action: PayloadAction<{ index: number, grouping: string }>
    ) {
      if (!state.dataSourceSidePanel.dataSourceFormState?.config) {
        state.dataSourceSidePanel.dataSourceFormState.config = {};
      }
      // resets groupings when adding/editing the first grouping
      if (action.payload.index === 0) {
        state.dataSourceSidePanel.dataSourceFormState.config.groupings = [];
      }

      state.dataSourceSidePanel.dataSourceFormState.config.groupings[
        action.payload.index
      ] = action.payload.grouping;
    },
    deleteDataSourceGrouping(state: ChartBuilderState) {
      // delete is only available for the addtional grouping
      // 1 grouping must be selected, and we can only support 2 groupings total
      if (state.dataSourceSidePanel.dataSourceFormState.config.groupings[1]) {
        state.dataSourceSidePanel.dataSourceFormState.config.groupings.pop();
        state.dataSourceSidePanel.dataSourceFormState.config.render_options.stack_group_elements =
          undefined;
      }
    },
    addFilter(
      state: ChartBuilderState,
      action: PayloadAction<{ type: FilterType, value: Array<FilterValue> }>
    ) {
      if (!state.dataSourceSidePanel.dataSourceFormState?.config) {
        state.dataSourceSidePanel.dataSourceFormState.config = {};
      }

      if (!state.dataSourceSidePanel.dataSourceFormState.config?.filters) {
        state.dataSourceSidePanel.dataSourceFormState.config.filters = {};
      }

      state.dataSourceSidePanel.dataSourceFormState.config.filters[
        action.payload.type
      ] = action.payload.value;
    },
    addRenderOptions(
      state: ChartBuilderState,
      action: PayloadAction<{
        key: RenderOptionType,
        value: RenderOptionValue,
      }>
    ) {
      if (!state.dataSourceSidePanel.dataSourceFormState?.config) {
        state.dataSourceSidePanel.dataSourceFormState.config = {};
      }

      if (
        !state.dataSourceSidePanel.dataSourceFormState.config?.render_options
      ) {
        state.dataSourceSidePanel.dataSourceFormState.config.render_options =
          {};
      }

      state.dataSourceSidePanel.dataSourceFormState.config.render_options[
        action.payload.key
      ] = action.payload.value;
    },
    setSidePanelSource(
      state: ChartBuilderState,
      action: PayloadAction<string>
    ) {
      state.dataSourceSidePanel.sidePanelSource = action.payload;
    },
    updateFormStateType(
      state: ChartBuilderState,
      action: PayloadAction<string>
    ) {
      state.dataSourceSidePanel.dataSourceFormState.type = action.payload;
      state.dataSourceSidePanel.dataSourceFormState.data_source_type =
        action.payload;
      state.dataSourceSidePanel.dataSourceFormState.input_params.subtypes = {};
    },
    setDataSourceSubtype(
      state: ChartBuilderState,
      action: PayloadAction<string>
    ) {
      state.dataSourceSidePanel.dataSourceFormState.input_params.subtypes = {
        ...state.dataSourceSidePanel.dataSourceFormState.input_params.subtypes,
        [action.payload.data.subtypeKey]: _cloneDeep(action.payload.data.value),
      };
    },
    refreshChartElements(
      state: ChartBuilderState,
      action: PayloadAction<{
        chartElements: Array<ChartElement>,
      }>
    ) {
      const widgetId = state.dataSourceSidePanel.widgetId;
      if (widgetId) {
        state.activeWidgets[widgetId].widget.chart_elements =
          action.payload.chartElements;
      }
    },
    updateLoaderLevel(
      state: ChartBuilderState,
      action: PayloadAction<{
        widgetId: string,
        loaderLevel: number,
      }>
    ) {
      const widgetId = action.payload.widgetId;
      const loaderLevel = action.payload.loaderLevel;
      if (!state?.loaderLevelMap) {
        state.loaderLevelMap = {};
      }
      state.loaderLevelMap = {
        ...state.loaderLevelMap,
        [widgetId]: loaderLevel,
      };
    },

    updateCachedAt(
      state: ChartBuilderState,
      action: PayloadAction<{
        widgetId: string,
        cachedAt: Array<string>,
      }>
    ) {
      const widgetId = action.payload.widgetId;
      const cachedAt = action.payload.cachedAt;
      if (!state?.cachedAtMap) {
        state.cachedAtMap = {};
      }

      state.cachedAtMap = {
        ...state.cachedAtMap,
        [widgetId]: cachedAt,
      };
    },
    refreshInvalidChartElementMap(
      state: ChartBuilderState,
      action: PayloadAction<{
        widgetId: string,
        invalidChartElementMap: { [key: string]: Array<string> },
      }>
    ) {
      const widgetId = action.payload.widgetId;
      if (widgetId) {
        state.activeWidgets[widgetId].widget.config = {
          ...state.activeWidgets[widgetId].widget.config,
          invalid_chart_elements: action.payload.invalidChartElementMap,
        };
      }
    },
    refreshWidgetCache(
      state: ChartBuilderState,
      action: PayloadAction<{
        widgetId: string,
        refreshCache?: boolean,
      }>
    ) {
      const { widgetId, refreshCache } = action.payload;

      state.refreshWidgetCacheMap = state.refreshWidgetCacheMap || {};
      state.refreshWidgetCacheMap[widgetId] = refreshCache;
    },
    updateChartName(
      state: ChartBuilderState,
      action: PayloadAction<{
        widgetId: string,
        name: string,
      }>
    ) {
      const widgetId = action.payload.widgetId;
      const name = action.payload.name;

      state.activeWidgets[widgetId].widget.name = name;
    },
    updateChartConfig(
      state: ChartBuilderState,
      action: PayloadAction<{
        chartId: string,
        partialConfig: ChartConfig,
      }>
    ) {
      const { chartId, partialConfig } = action.payload;

      if (!state?.[chartId]) {
        state[chartId] = {
          config: {},
        };
      }

      state[chartId].config = {
        ...state?.[chartId].config,
        ...partialConfig,
      };
    },
    toggleChartFormattingPanel(
      state: ChartBuilderState,
      action: PayloadAction<{ isOpen: boolean }>
    ) {
      state.chartFormattingPanel.isOpen = action.payload.isOpen;

      if (
        action.payload.isOpen &&
        state.dataSourceSidePanel.dataSourceFormState?.config?.render_options
          ?.conditional_formatting
      ) {
        state.chartFormattingPanel.appliedFormat =
          state.dataSourceSidePanel.dataSourceFormState.config.render_options.conditional_formatting;
      }

      if (!action.payload.isOpen) {
        state.chartFormattingPanel.appliedFormat = [];
      }
    },
    addFormattingRule(state: ChartBuilderState) {
      const appliedRules = state.chartFormattingPanel.appliedFormat;

      appliedRules.push({
        type: null,
        condition: null,
        value: null,
        color: colors.red_100_20,
      });
    },
    removeFormattingRule(
      state: ChartBuilderState,
      action: PayloadAction<{
        index: number,
      }>
    ) {
      const appliedRules = state.chartFormattingPanel.appliedFormat;

      appliedRules.splice(action.payload.index, 1);
    },
    addFormattingOption(
      state: ChartBuilderState,
      action: PayloadAction<{
        key: string,
        value: string,
        index: number,
      }>
    ) {
      const appliedRules = state.chartFormattingPanel.appliedFormat;

      appliedRules[action.payload.index] = {
        ...appliedRules[action.payload.index],
        [action.payload.key]: action.payload.value,
      };
    },
  },
});

export const {
  newChart,
  closeNewChartModal,
  beginWidgetEditMode,
  endWidgetEditMode,
  closeDataSourcePanel,
  setAllGroupings,
  addDataType,
  editDataType,
  applyChartElement,
  updateChartElement,
  deleteChartElement,
  addCalculation,
  addCalculationParams,
  addInputParams,
  addPopulation,
  addTimeScope,
  addDataSourceGroupingByIndex,
  deleteDataSourceGrouping,
  addFilter,
  updatePreviewChartData,
  addRenderOptions,
  setSidePanelSource,
  updateFormStateType,
  setDataSourceSubtype,
  updateChartName,
  updateChartConfig,
  updateLoaderLevel,
  updateCachedAt,
  refreshInvalidChartElementMap,
  refreshChartElements,
  refreshWidgetCache,
  toggleChartFormattingPanel,
  addFormattingRule,
  removeFormattingRule,
  addFormattingOption,
} = chartBuilder.actions;

export default chartBuilder.reducer;
